From efd7fc550ecb56a88ccc7dd73bec8c27ee9375ab Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sun, 30 Oct 2022 21:29:30 +0700
Subject: [PATCH 9/9] Fix Windows 98 compatibility

---
 src/drivers/driver_ndis.c         |  5 +++
 src/l2_packet/l2_packet_winpcap.c | 41 ++++++++++++++++++++++
 wpa_supplicant/wpa_supplicant.c   | 58 +++++++++++++++++++++++++++++++
 3 files changed, 104 insertions(+)

diff --git a/src/drivers/driver_ndis.c b/src/drivers/driver_ndis.c
index 3f1c1c6..da0f28b 100644
--- a/src/drivers/driver_ndis.c
+++ b/src/drivers/driver_ndis.c
@@ -1495,6 +1495,11 @@ static void wpa_driver_ndis_poll_timeout(void *eloop_ctx, void *timeout_ctx)
 #ifndef _WIN32_WCE
 	poll = 1;
 #endif /* _WIN32_WCE */
+#else /* CONFIG_NDIS_EVENTS_INTEGRATED */
+#ifndef _WIN32_WCE
+	if (!drv->events)
+		poll = 1;
+#endif /* _WIN32_WCE */
 #endif /* CONFIG_NDIS_EVENTS_INTEGRATED */
 
 	if (poll) {
diff --git a/src/l2_packet/l2_packet_winpcap.c b/src/l2_packet/l2_packet_winpcap.c
index 0bacde1..e60b4d1 100644
--- a/src/l2_packet/l2_packet_winpcap.c
+++ b/src/l2_packet/l2_packet_winpcap.c
@@ -27,6 +27,9 @@
  */
 
 #include "includes.h"
+#ifdef CONFIG_L2_IP_IPHLPAPI
+#include <iphlpapi.h>
+#endif /* CONFIG_L2_IP_IPHLPAPI */
 #include <pcap.h>
 
 #include "common.h"
@@ -319,6 +322,44 @@ int l2_packet_get_ip_addr(struct l2_packet_data *l2, char *buf, size_t len)
 	int found = 0;
 	char err[PCAP_ERRBUF_SIZE + 1];
 
+#ifdef CONFIG_L2_IP_IPHLPAPI
+	/*
+	 * On Win98 pcap_findalldevs returns devices with "0.0.0.0"
+	 * instead of a real IP address. In addition to the absence of
+	 * a result, call to this function leads to a system freeze for
+	 * a second. So we will try an alternative API.
+	 */
+	ULONG info_len = sizeof(IP_ADAPTER_INFO);
+	PIP_ADAPTER_INFO info = os_malloc(info_len);
+
+	if (GetAdaptersInfo(info, &info_len) == ERROR_BUFFER_OVERFLOW) {
+		os_free(info);
+		info = os_malloc(info_len);
+	}
+
+	if (GetAdaptersInfo(info, &info_len) == NO_ERROR) {
+		PIP_ADAPTER_INFO adapter;
+		for (adapter = info; adapter; adapter = adapter->Next) {
+			if (os_memcmp(adapter->Address, l2->own_addr, sizeof(l2->own_addr)) != 0)
+				continue;
+
+			if (adapter->CurrentIpAddress)
+				os_strlcpy(buf, adapter->CurrentIpAddress->IpAddress.String, len);
+			else
+				os_strlcpy(buf, adapter->IpAddressList.IpAddress.String, len);
+
+			if (os_strncmp(buf, "0.0.0.0", len) != 0)
+				found = 1;
+			break;
+		}
+	}
+
+	os_free(info);
+
+	if (found)
+		return 0;
+#endif /* CONFIG_L2_IP_IPHLPAPI */
+
 	if (pcap_findalldevs(&devs, err) < 0) {
 		wpa_printf(MSG_DEBUG, "pcap_findalldevs: %s\n", err);
 		return -1;
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index d37a994..d6f5114 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -15,6 +15,9 @@
 #include <net/if.h>
 #include <fnmatch.h>
 #endif /* CONFIG_MATCH_IFACE */
+#ifdef CONFIG_FORCE_DHCP_RENEW
+#include <iphlpapi.h>
+#endif /* CONFIG_FORCE_DHCP_RENEW */
 
 #include "common.h"
 #include "crypto/random.h"
@@ -926,6 +929,61 @@ void wpa_supplicant_set_state(struct wpa_supplicant *wpa_s,
 		wpa_supplicant_state_txt(wpa_s->wpa_state),
 		wpa_supplicant_state_txt(state));
 
+#ifdef CONFIG_FORCE_DHCP_RENEW
+	/*
+	 * On Win98 we have no correctly assigned IP address after
+	 * connection complete. A call to renew is required, but it doesn't
+	 * happen automatically. We will try to automate this by making
+	 * call to renew here. Also, on Win98 we have empty interface
+	 * names, so let's renew them all.
+	 */
+	if (state == WPA_COMPLETED && old_state != WPA_COMPLETED && LOBYTE(LOWORD(GetVersion())) < 5) {
+		ULONG info_len = 0;
+		if (GetInterfaceInfo(NULL, &info_len) == ERROR_INSUFFICIENT_BUFFER) {
+			PIP_INTERFACE_INFO info = os_malloc(info_len);
+			if (GetInterfaceInfo(info, &info_len) == NO_ERROR) {
+				LONG index;
+				for (index = 0; index < info->NumAdapters; ++index) {
+					size_t i;
+					char name[128];
+					for (i = 0; i < sizeof(name); ++i) {
+						name[i] = *((char*)(&(info->Adapter[index].Name[i])));
+						if (name[i] == '\0')
+							break;
+						else if (!isprint(name[i]))
+							name[i] = '_';
+					}
+
+					if (IpReleaseAddress(&info->Adapter[index]) == NO_ERROR) {
+						wpa_printf(MSG_DEBUG, "DHCP_RENEW: IP release succeeded "
+						           "for Name=%s, Index=%ld",
+						           name, info->Adapter[index].Index);
+					} else {
+						wpa_printf(MSG_DEBUG, "DHCP_RENEW: IP release failed "
+						           "for Name=%s, Index=%ld",
+						           name, info->Adapter[index].Index);
+					}
+
+					if (IpRenewAddress(&info->Adapter[index]) == NO_ERROR) {
+						wpa_printf(MSG_DEBUG, "DHCP_RENEW: IP renew succeeded "
+						           "for Name=%s, Index=%ld",
+						           name, info->Adapter[index].Index);
+					} else {
+						wpa_printf(MSG_DEBUG, "DHCP_RENEW: IP renew failed "
+						           "for Name=%s, Index=%ld",
+						           name, info->Adapter[index].Index);
+					}
+				}
+			} else {
+				wpa_printf(MSG_DEBUG, "DHCP_RENEW: GetInterfaceInfo failed");
+			}
+			os_free(info);
+		} else {
+			wpa_printf(MSG_DEBUG, "DHCP_RENEW: GetInterfaceInfo failed");
+		}
+	}
+#endif /* CONFIG_FORCE_DHCP_RENEW */
+
 	if (state == WPA_COMPLETED &&
 	    os_reltime_initialized(&wpa_s->roam_start)) {
 		os_reltime_age(&wpa_s->roam_start, &wpa_s->roam_time);
-- 
2.30.2

